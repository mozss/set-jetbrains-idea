<application>
  <component name="AppStorage">
    <option name="maxHistorySize" value="1000" />
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogHeight" value="726" />
    <option name="newTranslationDialogWidth" value="900" />
    <option name="newTranslationDialogX" value="747" />
    <option name="newTranslationDialogY" value="-1022" />
    <histories>
      <item value="&lt;h2&gt;About Moquette MQT broker&lt;h2&gt;&#10; &#10;&lt;p&gt;June 11, 2014&lt;p&gt;&#9;&#10;&lt;h3&gt;License&lt;h3&gt;&#10;&#10;&lt;p&gt;The Content is provided to you under the terms and conditions of the&#10;Eclipse Public License Version 1.0 (&amp;quot;EPL&amp;quot;).  A copy of the EPL is available &#10;at &lt;a href=&quot;http:www.eclipse.orglegalepl-v10.html&quot;&gt;http:www.eclipse.orglegalepl-v10.html&lt;a&gt;.&#10;For purposes of the EPL, &amp;quot;Program&amp;quot; will mean the Content.&lt;p&gt;&#10;&#10;&lt;p&gt;The Content is &#10;being redistributed by another party (&amp;quot;Redistributor&amp;quot;) and different terms and conditions may&#10;apply to your use of any object code in the Content.  Check the Redistributor's license that was &#10;provided with the Content.  If no such license exists, contact the Redistributor.  Unless otherwise&#10;indicated below, the terms and conditions of the EPL still apply to any source code in the Content&#10;and such source code may be obtained at &lt;a href=&quot;http:www.eclipse.org&quot;&gt;http:www.eclipse.org&lt;a&gt;.&lt;p&gt;&#10;&#10;&lt;body" />
      <item value="&lt;!DOCTYPE html PUBLIC &quot;-W3CDTD XHTML 1.0 StrictEN&quot; &quot;http:www.w3.orgTRxhtml1DTDxhtml1-strict.dtd&quot;&gt; &lt;html xmlns=&quot;http:www.w3.org1999xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;texthtml; charset=ISO-8859-1&quot;&gt; &lt;title&gt;About&lt;title&gt; &lt;head&gt; &lt;body lang=&quot;EN-US&quot;&gt; &lt;h2&gt;About Moquette MQT broker&lt;h2&gt; &lt;p&gt;June 11, 2014&lt;p&gt; &lt;h3&gt;License&lt;h3&gt; &lt;p&gt;The Content is provided to you under the terms and conditions of the Eclipse Public License Version 1.0 (&amp;quot;EPL&amp;quot;). A copy of the EPL is available at &lt;a href=&quot;http:www.eclipse.orglegalepl-v10.html&quot;&gt;http:www.eclipse.orglegalepl-v10.html&lt;a&gt;. For purposes of the EPL, &amp;quot;Program&amp;quot; will mean the Content.&lt;p&gt; &lt;p&gt;The Content is being redistributed by another party (&amp;quot;Redistributor&amp;quot;) and different terms and conditions may apply to your use of any object code in the Content. Check the Redistributor's license that was provided with the Content. If no such license exists, contact the Redistributor. Unless otherwise indicated below, the terms and conditions of the EPL still apply to any source code in the Content and such source code may be obtained at &lt;a href=&quot;http:www.eclipse.org&quot;&gt;http:www.eclipse.org&lt;a&gt;.&lt;p&gt; &lt;body&gt; &lt;html&gt;" />
      <item value="Usage:&#10;- Open a file, put the cursor inside of the PlantUML code to render it&#10;- PlantUML code must be inside of @startuml and @enduml tags to be rendered, or their equivalent&#10;- You might need to install Graphviz and set a path to it (not needed for Windows, it is embedded in PlantUML) &#10;&#10;- A new file can be created from template (File | New | PlantUML File)&#10;- PlantUML code can be placed anywhere, '*' are ignored for usage in Java comments&#10;- About screen tests Graphviz installation&#10;&#10;- Clicking on the rendered image's text finds it in the source&#10;- Ctrl + Click in the editor navigates between occurrences&#10;- File Structure displays the first occurrence&#10;&#10;Intentions (Alt+Enter):&#10;- reverse arrow&#10;- with a caret on top of @startuml:&#10; - disable syntax check&#10; - enable partial rendering - renders each page on it's own, useful for big sequence diagram files&#10;&#10;Diagram [[file links]]:&#10;- supported paths: relative to the source code file, relative to module content roots, absolute&#10;- methods, fields, variables and other identifiers can be referenced by suffix, e.g. file.java#methodName&#10;- paths with spaces are not supported&#10;&#10;Performance tips:&#10;- disable automatic rendering and use Update (Ctrl Alt Shift F) or Reload (Ctrl Alt Shift G) buttons&#10;- do not put @newpage into included files (it prohibits incremental and partial rendering)&#10;- try to enable partial rendering - add to the first page: 'idea.partialRender &#10;- disable 'Render links for PNG'&#10;- disable syntax checking - add to the first page: 'idea.disableSyntaxCheck&#10;- reduce limits and disable 'SVG preview scaling'&#10;- tune cache size in settings, make sure you have enough heap memory (enable Memory Indicator)&#10;&#10;Other supported PlantUML features:&#10;- @startuml &lt;filename&gt; - changes default filename when saving/exporting&#10;- Settings | PlantUML config - useful for global 'skinparam' command&#10;" />
      <item value="Do not process draft" />
      <item value="Transform title into titlecas" />
      <item value="Transform title into titlecase" />
      <item value="plain" />
      <item value="MacOS specific nameserver resolution." />
      <item value="Extensible decoder and its common implementations which deal with the packet fragmentation and reassembly issue found in a stream-based transport such as TCPIP." />
      <item value="If the sequence is a string, use reflection to share its array" />
      <item value="This file was mechanically generated: Do not edit!" />
      <item value="A typesafe enumeration for byte orders" />
      <item value="Copyright 2012-2022 the original author or authors. Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at https:www.apache.orglicensesLICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. package org.springframework.boot; import java.time.Duration; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Properties; import java.util.Set; import java.util.stream.Collectors; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.springframework.aot.AotDetector; import org.springframework.beans.BeansException; import org.springframework.beans.CachedIntrospectionResults; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.config.BeanFactoryPostProcessor; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader; import org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.beans.factory.support.BeanNameGenerator; import org.springframework.beans.factory.support.DefaultListableBeanFactory; import org.springframework.beans.factory.xml.XmlBeanDefinitionReader; import org.springframework.boot.Banner.Mode; import org.springframework.boot.context.properties.bind.Bindable; import org.springframework.boot.context.properties.bind.Binder; import org.springframework.boot.context.properties.source.ConfigurationPropertySources; import org.springframework.boot.convert.ApplicationConversionService; import org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext; import org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextInitializer; import org.springframework.context.ApplicationListener; import org.springframework.context.ConfigurableApplicationContext; import org.springframework.context.annotation.AnnotatedBeanDefinitionReader; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.annotation.AnnotationConfigUtils; import org.springframework.context.annotation.ClassPathBeanDefinitionScanner; import org.springframework.context.annotation.ConfigurationClassPostProcessor; import org.springframework.context.aot.ApplicationContextAotInitializer; import org.springframework.context.support.AbstractApplicationContext; import org.springframework.context.support.GenericApplicationContext; import org.springframework.core.GenericTypeResolver; import org.springframework.core.Ordered; import org.springframework.core.annotation.AnnotationAwareOrderComparator; import org.springframework.core.annotation.Order; import org.springframework.core.env.CommandLinePropertySource; import org.springframework.core.env.CompositePropertySource; import org.springframework.core.env.ConfigurableEnvironment; import org.springframework.core.env.Environment; import org.springframework.core.env.MutablePropertySources; import org.springframework.core.env.PropertySource; import org.springframework.core.env.SimpleCommandLinePropertySource; import org.springframework.core.env.StandardEnvironment; import org.springframework.core.io.DefaultResourceLoader; import org.springframework.core.io.ResourceLoader; import org.springframework.core.io.support.SpringFactoriesLoader; import org.springframework.core.io.support.SpringFactoriesLoader.ArgumentResolver; import org.springframework.core.metrics.ApplicationStartup; import org.springframework.util.Assert; import org.springframework.util.ClassUtils; import org.springframework.util.CollectionUtils; import org.springframework.util.ObjectUtils; import org.springframework.util.ReflectionUtils; import org.springframework.util.StringUtils; Class that can be used to bootstrap and launch a Spring application from a Java main method. By default class will perform the following steps to bootstrap your application: &lt;ul&gt; &lt;li&gt;Create an appropriate {@link ApplicationContext} instance (depending on your classpath)&lt;li&gt; &lt;li&gt;Register a {@link CommandLinePropertySource} to expose command line arguments as Spring properties&lt;li&gt; &lt;li&gt;Refresh the application context, loading all singleton beans&lt;li&gt; &lt;li&gt;Trigger any {@link CommandLineRunner} beans&lt;li&gt; &lt;ul&gt; In most circumstances the static {@link run(Class, String[])} method can be called directly from your {@literal main} method to bootstrap your application: &lt;pre class=&quot;code&quot;&gt; &amp;064;Configuration &amp;064;EnableAutoConfiguration public class MyApplication { ... Bean definitions public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } &lt;pre&gt; &lt;p&gt; For more advanced configuration a {@link SpringApplication} instance can be created and customized before being run: &lt;pre class=&quot;code&quot;&gt; public static void main(String[] args) { SpringApplication application = new SpringApplication(MyApplication.class); ... customize application settings here application.run(args) } &lt;pre&gt; {@link SpringApplication}s can read beans from a variety of different sources. It is generally recommended that a single {@code @Configuration} class is used to bootstrap your application, however, you may also set {@link getSources() sources} from: &lt;ul&gt; &lt;li&gt;The fully qualified class name to be loaded by {@link AnnotatedBeanDefinitionReader}&lt;li&gt; &lt;li&gt;The location of an XML resource to be loaded by {@link XmlBeanDefinitionReader}, or a groovy script to be loaded by {@link GroovyBeanDefinitionReader}&lt;li&gt; &lt;li&gt;The name of a package to be scanned by {@link ClassPathBeanDefinitionScanner}&lt;li&gt; &lt;ul&gt; Configuration properties are also bound to the {@link SpringApplication}. This makes it possible to set {@link SpringApplication} properties dynamically, like additional sources (&quot;spring.main.sources&quot; - a CSV list) the flag to indicate a web environment (&quot;spring.main.web-application-type=none&quot;) or the flag to switch off the banner (&quot;spring.main.banner-mode=off&quot;). @author Phillip Webb @author Dave Syer @author Andy Wilkinson @author Christian Dupuis @author Stephane Nicoll @author Jeremy Rickard @author Craig Burke @author Michael Simons @author Madhura Bhave @author Brian Clozel @author Ethan Rubinson @author Chris Bono @since 1.0.0 @see run(Class, String[]) @see run(Class[], String[]) @see SpringApplication(Class...) public class SpringApplication { Default banner location. public static final String BANNER_LOCATION_PROPERTY_VALUE = SpringApplicationBannerPrinter.DEFAULT_BANNER_LOCATION; Banner location property key. public static final String BANNER_LOCATION_PROPERTY = SpringApplicationBannerPrinter.BANNER_LOCATION_PROPERTY; private static final String SYSTEM_PROPERTY_JAVA_AWT_HEADLESS = &quot;java.awt.headless&quot;; private static final Log logger = LogFactory.getLog(SpringApplication.class); static final SpringApplicationShutdownHook shutdownHook = new SpringApplicationShutdownHook(); private Set&lt;Class&lt;?&gt;&gt; primarySources; private Set&lt;String&gt; sources = new LinkedHashSet&lt;&gt;(); private Class&lt;?&gt; mainApplicationClass; private Banner.Mode bannerMode = Banner.Mode.CONSOLE; private boolean logStartupInfo = true; private boolean addCommandLineProperties = true; private boolean addConversionService = true; private Banner banner; private ResourceLoader resourceLoader; private BeanNameGenerator beanNameGenerator; private ConfigurableEnvironment environment; private WebApplicationType webApplicationType; private boolean headless = true; private boolean registerShutdownHook = true; private List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers; private List&lt;ApplicationListener&lt;?&gt;&gt; listeners; private Map&lt;String, Object&gt; defaultProperties; private List&lt;BootstrapRegistryInitializer&gt; bootstrapRegistryInitializers; private Set&lt;String&gt; additionalProfiles = Collections.emptySet(); private boolean allowBeanDefinitionOverriding; private boolean allowCircularReferences; private boolean isCustomEnvironment = false; private boolean lazyInitialization = false; private String environmentPrefix; private ApplicationContextFactory applicationContextFactory = ApplicationContextFactory.DEFAULT; private ApplicationStartup applicationStartup = ApplicationStartup.DEFAULT; Create a new {@link SpringApplication} instance. The application context will load beans from the specified primary sources (see {@link SpringApplication class-level} documentation for details). The instance can be customized before calling {@link run(String...)}. @param primarySources the primary bean sources @see run(Class, String[]) @see SpringApplication(ResourceLoader, Class...) @see setSources(Set) public SpringApplication(Class&lt;?&gt;... primarySources) { this(null, primarySources); } Create a new {@link SpringApplication} instance. The application context will load beans from the specified primary sources (see {@link SpringApplication class-level} documentation for details). The instance can be customized before calling {@link run(String...)}. @param resourceLoader the resource loader to use @param primarySources the primary bean sources @see run(Class, String[]) @see setSources(Set) @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; }) public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.bootstrapRegistryInitializers = new ArrayList&lt;&gt;( getSpringFactoriesInstances(BootstrapRegistryInitializer.class)); setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass(); } private Class&lt;?&gt; deduceMainApplicationClass() { try { StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) { if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) { return Class.forName(stackTraceElement.getClassName()); } } } catch (ClassNotFoundException ex) { Swallow and continue } return null; } Run the Spring application, creating and refreshing a new {@link ApplicationContext}. @param args the application arguments (usually passed from a Java main method) @return a running {@link ApplicationContext} public ConfigurableApplicationContext run(String... args) { SpringApplicationHooks.hooks().preRun(this); long startTime = System.nanoTime(); DefaultBootstrapContext bootstrapContext = createBootstrapContext(); ConfigurableApplicationContext context = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(bootstrapContext, this.mainApplicationClass); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); configureIgnoreBeanInfo(environment); Banner printedBanner = printBanner(environment); context = createApplicationContext(); context.setApplicationStartup(this.applicationStartup); prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); if (refreshContext(context)) { afterRefresh(context, applicationArguments); Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup); } listeners.started(context, timeTakenToStartup); callRunners(context, applicationArguments); } } catch (Throwable ex) { handleRunFailure(context, ex, listeners); throw new IllegalStateException(ex); } try { if (context.isRunning()) { Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime); listeners.ready(context, timeTakenToReady); } } catch (Throwable ex) { handleRunFailure(context, ex, null); throw new IllegalStateException(ex); } SpringApplicationHooks.hooks().postRun(this, context); return context; } private DefaultBootstrapContext createBootstrapContext() { DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext(); this.bootstrapRegistryInitializers.forEach((initializer) -&gt; initializer.initialize(bootstrapContext)); return bootstrapContext; } private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) { Create and configure the environment ConfigurableEnvironment environment = getOrCreateEnvironment(); configureEnvironment(environment, applicationArguments.getSourceArgs()); ConfigurationPropertySources.attach(environment); listeners.environmentPrepared(bootstrapContext, environment); DefaultPropertiesPropertySource.moveToEnd(environment); Assert.state(!environment.containsProperty(&quot;spring.main.environment-prefix&quot;), &quot;Environment prefix cannot be set via properties.&quot;); bindToSpringApplication(environment); if (!this.isCustomEnvironment) { EnvironmentConverter environmentConverter = new EnvironmentConverter(getClassLoader()); environment = environmentConverter.convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); } ConfigurationPropertySources.attach(environment); return environment; } private Class&lt;? extends StandardEnvironment&gt; deduceEnvironmentClass() { return switch (this.webApplicationType) { case SERVLET -&gt; ApplicationServletEnvironment.class; case REACTIVE -&gt; ApplicationReactiveWebEnvironment.class; default -&gt; ApplicationEnvironment.class; }; } private void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) { context.setEnvironment(environment); postProcessApplicationContext(context); addAotGeneratedInitializerIfNecessary(this.initializers); applyInitializers(context); listeners.contextPrepared(context); bootstrapContext.close(context); if (this.logStartupInfo) { logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); } Add boot specific singleton beans ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); if (printedBanner != null) { beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); } if (beanFactory instanceof AbstractAutowireCapableBeanFactory autowireCapableBeanFactory) { autowireCapableBeanFactory.setAllowCircularReferences(this.allowCircularReferences); if (beanFactory instanceof DefaultListableBeanFactory listableBeanFactory) { listableBeanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); } } if (this.lazyInitialization) { context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()); } context.addBeanFactoryPostProcessor(new PropertySourceOrderingBeanFactoryPostProcessor(context)); if (!AotDetector.useGeneratedArtifacts()) { Load the sources Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); load(context, sources.toArray(new Object[0])); } listeners.contextLoaded(context); } private void addAotGeneratedInitializerIfNecessary(List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers) { if (AotDetector.useGeneratedArtifacts()) { String initializerClassName = this.mainApplicationClass.getName() + &quot;__ApplicationContextInitializer&quot;; if (logger.isDebugEnabled()) { logger.debug(&quot;Using AOT generated initializer: &quot; + initializerClassName); } initializers.add(0, (context) -&gt; new ApplicationContextAotInitializer().initialize(context, initializerClassName)); } } private boolean refreshContext(ConfigurableApplicationContext context) { if (!SpringApplicationHooks.hooks().preRefresh(this, context)) { return false; } if (this.registerShutdownHook) { shutdownHook.registerApplicationContext(context); } refresh(context); return true; } private void configureHeadlessProperty() { System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless))); } private SpringApplicationRunListeners getRunListeners(String[] args) { ArgumentResolver argumentResolver = ArgumentResolver.of(SpringApplication.class, this); argumentResolver = argumentResolver.and(String[].class, args); Collection&lt;SpringApplicationRunListener&gt; listeners = getSpringFactoriesInstances( SpringApplicationRunListener.class, argumentResolver); return new SpringApplicationRunListeners(logger, listeners, this.applicationStartup); } private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) { return getSpringFactoriesInstances(type, null); } private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, ArgumentResolver argumentResolver) { return SpringFactoriesLoader.forDefaultResourceLocation(getClassLoader()).load(type, argumentResolver); } private ConfigurableEnvironment getOrCreateEnvironment() { if (this.environment != null) { return this.environment; } return switch (this.webApplicationType) { case SERVLET -&gt; new ApplicationServletEnvironment(); case REACTIVE -&gt; new ApplicationReactiveWebEnvironment(); default -&gt; new ApplicationEnvironment(); }; } Template method delegating to {@link configurePropertySources(ConfigurableEnvironment, String[])} and {@link configureProfiles(ConfigurableEnvironment, String[])} in that order. Override this method for complete control over Environment customization, or one of the above for fine-grained control over property sources or profiles, respectively. @param environment this application's environment @param args arguments passed to the {@code run} method @see configureProfiles(ConfigurableEnvironment, String[]) @see configurePropertySources(ConfigurableEnvironment, String[]) protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) { if (this.addConversionService) { environment.setConversionService(new ApplicationConversionService()); } configurePropertySources(environment, args); configureProfiles(environment, args); } Add, remove or re-order any {@link PropertySource}s in this application's environment. @param environment this application's environment @param args arguments passed to the {@code run} method @see configureEnvironment(ConfigurableEnvironment, String[]) protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) { MutablePropertySources sources = environment.getPropertySources(); if (!CollectionUtils.isEmpty(this.defaultProperties)) { DefaultPropertiesPropertySource.addOrMerge(this.defaultProperties, sources); } if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) { String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME; if (sources.contains(name)) { PropertySource&lt;?&gt; source = sources.get(name); CompositePropertySource composite = new CompositePropertySource(name); composite.addPropertySource( new SimpleCommandLinePropertySource(&quot;springApplicationCommandLineArgs&quot;, args)); composite.addPropertySource(source); sources.replace(name, composite); } else { sources.addFirst(new SimpleCommandLinePropertySource(args)); } } } Configure which profiles are active (or active by default) for this application environment. Additional profiles may be activated during configuration file processing via the {@code spring.profiles.active} property. @param environment this application's environment @param args arguments passed to the {@code run} method @see configureEnvironment(ConfigurableEnvironment, String[]) protected void configureProfiles(ConfigurableEnvironment environment, String[] args) { } private void configureIgnoreBeanInfo(ConfigurableEnvironment environment) { if (System.getProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME) == null) { Boolean ignore = environment.getProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, Boolean.class, Boolean.TRUE); System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, ignore.toString()); } } Bind the environment to the {@link SpringApplication}. @param environment the environment to bind protected void bindToSpringApplication(ConfigurableEnvironment environment) { try { Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this)); } catch (Exception ex) { throw new IllegalStateException(&quot;Cannot bind to SpringApplication&quot;, ex); } } private Banner printBanner(ConfigurableEnvironment environment) { if (this.bannerMode == Banner.Mode.OFF) { return null; } ResourceLoader resourceLoader = (this.resourceLoader != null) ? this.resourceLoader : new DefaultResourceLoader(null); SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(resourceLoader, this.banner); if (this.bannerMode == Mode.LOG) { return bannerPrinter.print(environment, this.mainApplicationClass, logger); } return bannerPrinter.print(environment, this.mainApplicationClass, System.out); } Strategy method used to create the {@link ApplicationContext}. By default this method will respect any explicitly set application context class or factory before falling back to a suitable default. @return the application context (not yet refreshed) @see setApplicationContextFactory(ApplicationContextFactory) protected ConfigurableApplicationContext createApplicationContext() { return this.applicationContextFactory.create(this.webApplicationType); } Apply any relevant post processing the {@link ApplicationContext}. Subclasses can apply additional processing as required. @param context the application context protected void postProcessApplicationContext(ConfigurableApplicationContext context) { if (this.beanNameGenerator != null) { context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, this.beanNameGenerator); } if (this.resourceLoader != null) { if (context instanceof GenericApplicationContext genericApplicationContext) { genericApplicationContext.setResourceLoader(this.resourceLoader); } if (context instanceof DefaultResourceLoader defaultResourceLoader) { defaultResourceLoader.setClassLoader(this.resourceLoader.getClassLoader()); } } if (this.addConversionService) { context.getBeanFactory().setConversionService(context.getEnvironment().getConversionService()); } } Apply any {@link ApplicationContextInitializer}s to the context before it is refreshed. @param context the configured ApplicationContext (not refreshed yet) @see ConfigurableApplicationContextrefresh() @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; }) protected void applyInitializers(ConfigurableApplicationContext context) { for (ApplicationContextInitializer initializer : getInitializers()) { Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(), ApplicationContextInitializer.class); Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;); initializer.initialize(context); } } Called to log startup information, subclasses may override to add additional logging. @param isRoot true if this application is the root of a context hierarchy protected void logStartupInfo(boolean isRoot) { if (isRoot) { new StartupInfoLogger(this.mainApplicationClass).logStarting(getApplicationLog()); } } Called to log active profile information. @param context the application context protected void logStartupProfileInfo(ConfigurableApplicationContext context) { Log log = getApplicationLog(); if (log.isInfoEnabled()) { List&lt;String&gt; activeProfiles = quoteProfiles(context.getEnvironment().getActiveProfiles()); if (ObjectUtils.isEmpty(activeProfiles)) { List&lt;String&gt; defaultProfiles = quoteProfiles(context.getEnvironment().getDefaultProfiles()); String message = String.format(&quot;%s default %s: &quot;, defaultProfiles.size(), (defaultProfiles.size() &lt;= 1) ? &quot;profile&quot; : &quot;profiles&quot;); log.info(&quot;No active profile set, falling back to &quot; + message + StringUtils.collectionToDelimitedString(defaultProfiles, &quot;, &quot;)); } else { String message = (activeProfiles.size() == 1) ? &quot;1 profile is active: &quot; : activeProfiles.size() + &quot; profiles are active: &quot;; log.info(&quot;The following &quot; + message + StringUtils.collectionToDelimitedString(activeProfiles, &quot;, &quot;)); } } } private List&lt;String&gt; quoteProfiles(String[] profiles) { return Arrays.stream(profiles).map((profile) -&gt; &quot;\&quot;&quot; + profile + &quot;\&quot;&quot;).collect(Collectors.toList()); } Returns the {@link Log} for the application. By default will be deduced. @return the application log protected Log getApplicationLog() { if (this.mainApplicationClass == null) { return logger; } return LogFactory.getLog(this.mainApplicationClass); } Load beans into the application context. @param context the context to load beans into @param sources the sources to load protected void load(ApplicationContext context, Object[] sources) { if (logger.isDebugEnabled()) { logger.debug(&quot;Loading source &quot; + StringUtils.arrayToCommaDelimitedString(sources)); } BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources); if (this.beanNameGenerator != null) { loader.setBeanNameGenerator(this.beanNameGenerator); } if (this.resourceLoader != null) { loader.setResourceLoader(this.resourceLoader); } if (this.environment != null) { loader.setEnvironment(this.environment); } loader.load(); } The ResourceLoader that will be used in the ApplicationContext. @return the resourceLoader the resource loader that will be used in the ApplicationContext (or null if the default) public ResourceLoader getResourceLoader() { return this.resourceLoader; } Either the ClassLoader that will be used in the ApplicationContext (if {@link setResourceLoader(ResourceLoader) resourceLoader} is set), or the context class loader (if not null), or the loader of the Spring {@link ClassUtils} class. @return a ClassLoader (never null) public ClassLoader getClassLoader() { if (this.resourceLoader != null) { return this.resourceLoader.getClassLoader(); } return ClassUtils.getDefaultClassLoader(); } Get the bean definition registry. @param context the application context @return the BeanDefinitionRegistry if it can be determined private BeanDefinitionRegistry getBeanDefinitionRegistry(ApplicationContext context) { if (context instanceof BeanDefinitionRegistry registry) { return registry; } if (context instanceof AbstractApplicationContext abstractApplicationContext) { return (BeanDefinitionRegistry) abstractApplicationContext.getBeanFactory(); } throw new IllegalStateException(&quot;Could not locate BeanDefinitionRegistry&quot;); } Factory method used to create the {@link BeanDefinitionLoader}. @param registry the bean definition registry @param sources the sources to load @return the {@link BeanDefinitionLoader} that will be used to load beans protected BeanDefinitionLoader createBeanDefinitionLoader(BeanDefinitionRegistry registry, Object[] sources) { return new BeanDefinitionLoader(registry, sources); } Refresh the underlying {@link ApplicationContext}. @param applicationContext the application context to refresh protected void refresh(ConfigurableApplicationContext applicationContext) { applicationContext.refresh(); } Called after the context has been refreshed. @param context the application context @param args the application arguments protected void afterRefresh(ConfigurableApplicationContext context, ApplicationArguments args) { } private void callRunners(ApplicationContext context, ApplicationArguments args) { List&lt;Object&gt; runners = new ArrayList&lt;&gt;(); runners.addAll(context.getBeansOfType(ApplicationRunner.class).values()); runners.addAll(context.getBeansOfType(CommandLineRunner.class).values()); AnnotationAwareOrderComparator.sort(runners); for (Object runner : new LinkedHashSet&lt;&gt;(runners)) { if (runner instanceof ApplicationRunner applicationRunner) { callRunner(applicationRunner, args); } if (runner instanceof CommandLineRunner commandLineRunner) { callRunner(commandLineRunner, args); } } } private void callRunner(ApplicationRunner runner, ApplicationArguments args) { try { (runner).run(args); } catch (Exception ex) { throw new IllegalStateException(&quot;Failed to execute ApplicationRunner&quot;, ex); } } private void callRunner(CommandLineRunner runner, ApplicationArguments args) { try { (runner).run(args.getSourceArgs()); } catch (Exception ex) { throw new IllegalStateException(&quot;Failed to execute CommandLineRunner&quot;, ex); } } private void handleRunFailure(ConfigurableApplicationContext context, Throwable exception, SpringApplicationRunListeners listeners) { try { try { handleExitCode(context, exception); if (listeners != null) { listeners.failed(context, exception); } } finally { reportFailure(getExceptionReporters(context), exception); if (context != null) { context.close(); shutdownHook.deregisterFailedApplicationContext(context); } } } catch (Exception ex) { logger.warn(&quot;Unable to close ApplicationContext&quot;, ex); } ReflectionUtils.rethrowRuntimeException(exception); } private Collection&lt;SpringBootExceptionReporter&gt; getExceptionReporters(ConfigurableApplicationContext context) { try { ArgumentResolver argumentResolver = ArgumentResolver.of(ConfigurableApplicationContext.class, context); return getSpringFactoriesInstances(SpringBootExceptionReporter.class, argumentResolver); } catch (Throwable ex) { return Collections.emptyList(); } } private void reportFailure(Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters, Throwable failure) { try { for (SpringBootExceptionReporter reporter : exceptionReporters) { if (reporter.reportException(failure)) { registerLoggedException(failure); return; } } } catch (Throwable ex) { Continue with normal handling of the original failure } if (logger.isErrorEnabled()) { logger.error(&quot;Application run failed&quot;, failure); registerLoggedException(failure); } } Register that the given exception has been logged. By default, if the running in the main thread, this method will suppress additional printing of the stacktrace. @param exception the exception that was logged protected void registerLoggedException(Throwable exception) { SpringBootExceptionHandler handler = getSpringBootExceptionHandler(); if (handler != null) { handler.registerLoggedException(exception); } } private void handleExitCode(ConfigurableApplicationContext context, Throwable exception) { int exitCode = getExitCodeFromException(context, exception); if (exitCode != 0) { if (context != null) { context.publishEvent(new ExitCodeEvent(context, exitCode)); } SpringBootExceptionHandler handler = getSpringBootExceptionHandler(); if (handler != null) { handler.registerExitCode(exitCode); } } } private int getExitCodeFromException(ConfigurableApplicationContext context, Throwable exception) { int exitCode = getExitCodeFromMappedException(context, exception); if (exitCode == 0) { exitCode = getExitCodeFromExitCodeGeneratorException(exception); } return exitCode; } private int getExitCodeFromMappedException(ConfigurableApplicationContext context, Throwable exception) { if (context == null || !context.isActive()) { return 0; } ExitCodeGenerators generators = new ExitCodeGenerators(); Collection&lt;ExitCodeExceptionMapper&gt; beans = context.getBeansOfType(ExitCodeExceptionMapper.class).values(); generators.addAll(exception, beans); return generators.getExitCode(); } private int getExitCodeFromExitCodeGeneratorException(Throwable exception) { if (exception == null) { return 0; } if (exception instanceof ExitCodeGenerator generator) { return generator.getExitCode(); } return getExitCodeFromExitCodeGeneratorException(exception.getCause()); } SpringBootExceptionHandler getSpringBootExceptionHandler() { if (isMainThread(Thread.currentThread())) { return SpringBootExceptionHandler.forCurrentThread(); } return null; } private boolean isMainThread(Thread currentThread) { return (&quot;main&quot;.equals(currentThread.getName()) || &quot;restartedMain&quot;.equals(currentThread.getName())) &amp;&amp; &quot;main&quot;.equals(currentThread.getThreadGroup().getName()); } Returns the main application class that has been deduced or explicitly configured. @return the main application class or {@code null} public Class&lt;?&gt; getMainApplicationClass() { return this.mainApplicationClass; } Set a specific main application class that will be used as a log source and to obtain version information. By default the main application class will be deduced. Can be set to {@code null} if there is no explicit application class. @param mainApplicationClass the mainApplicationClass to set or {@code null} public void setMainApplicationClass(Class&lt;?&gt; mainApplicationClass) { this.mainApplicationClass = mainApplicationClass; } Returns the type of web application that is being run. @return the type of web application @since 2.0.0 public WebApplicationType getWebApplicationType() { return this.webApplicationType; } Sets the type of web application to be run. If not explicitly set the type of web application will be deduced based on the classpath. @param webApplicationType the web application type @since 2.0.0 public void setWebApplicationType(WebApplicationType webApplicationType) { Assert.notNull(webApplicationType, &quot;WebApplicationType must not be null&quot;); this.webApplicationType = webApplicationType; } Sets if bean definition overriding, by registering a definition with the same name as an existing definition, should be allowed. Defaults to {@code false}. @param allowBeanDefinitionOverriding if overriding is allowed @since 2.1.0 @see DefaultListableBeanFactorysetAllowBeanDefinitionOverriding(boolean) public void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) { this.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding; } Sets whether to allow circular references between beans and automatically try to resolve them. Defaults to {@code false}. @param allowCircularReferences if circular references are allowed @since 2.6.0 @see AbstractAutowireCapableBeanFactorysetAllowCircularReferences(boolean) public void setAllowCircularReferences(boolean allowCircularReferences) { this.allowCircularReferences = allowCircularReferences; } Sets if beans should be initialized lazily. Defaults to {@code false}. @param lazyInitialization if initialization should be lazy @since 2.2 @see BeanDefinitionsetLazyInit(boolean) public void setLazyInitialization(boolean lazyInitialization) { this.lazyInitialization = lazyInitialization; } Sets if the application is headless and should not instantiate AWT. Defaults to {@code true} to prevent java icons appearing. @param headless if the application is headless public void setHeadless(boolean headless) { this.headless = headless; } Sets if the created {@link ApplicationContext} should have a shutdown hook registered. Defaults to {@code true} to ensure that JVM shutdowns are handled gracefully. @param registerShutdownHook if the shutdown hook should be registered @see getShutdownHandlers() public void setRegisterShutdownHook(boolean registerShutdownHook) { this.registerShutdownHook = registerShutdownHook; } Sets the {@link Banner} instance which will be used to print the banner when no static banner file is provided. @param banner the Banner instance to use public void setBanner(Banner banner) { this.banner = banner; } Sets the mode used to display the banner when the application runs. Defaults to {@code Banner.Mode.CONSOLE}. @param bannerMode the mode used to display the banner public void setBannerMode(Banner.Mode bannerMode) { this.bannerMode = bannerMode; } Sets if the application information should be logged when the application starts. Defaults to {@code true}. @param logStartupInfo if startup info should be logged. public void setLogStartupInfo(boolean logStartupInfo) { this.logStartupInfo = logStartupInfo; } Sets if a {@link CommandLinePropertySource} should be added to the application context in order to expose arguments. Defaults to {@code true}. @param addCommandLineProperties if command line arguments should be exposed public void setAddCommandLineProperties(boolean addCommandLineProperties) { this.addCommandLineProperties = addCommandLineProperties; } Sets if the {@link ApplicationConversionService} should be added to the application context's {@link Environment}. @param addConversionService if the application conversion service should be added @since 2.1.0 public void setAddConversionService(boolean addConversionService) { this.addConversionService = addConversionService; } Adds {@link BootstrapRegistryInitializer} instances that can be used to initialize the {@link BootstrapRegistry}. @param bootstrapRegistryInitializer the bootstrap registry initializer to add @since 2.4.5 public void addBootstrapRegistryInitializer(BootstrapRegistryInitializer bootstrapRegistryInitializer) { Assert.notNull(bootstrapRegistryInitializer, &quot;BootstrapRegistryInitializer must not be null&quot;); this.bootstrapRegistryInitializers.addAll(Arrays.asList(bootstrapRegistryInitializer)); } Set default environment properties which will be used in addition to those in the existing {@link Environment}. @param defaultProperties the additional properties to set public void setDefaultProperties(Map&lt;String, Object&gt; defaultProperties) { this.defaultProperties = defaultProperties; } Convenient alternative to {@link setDefaultProperties(Map)}. @param defaultProperties some {@link Properties} public void setDefaultProperties(Properties defaultProperties) { this.defaultProperties = new HashMap&lt;&gt;(); for (Object key : Collections.list(defaultProperties.propertyNames())) { this.defaultProperties.put((String) key, defaultProperties.get(key)); } } Set additional profile values to use (on top of those set in system or command line properties). @param profiles the additional profiles to set public void setAdditionalProfiles(String... profiles) { this.additionalProfiles = Collections.unmodifiableSet(new LinkedHashSet&lt;&gt;(Arrays.asList(profiles))); } Return an immutable set of any additional profiles in use. @return the additional profiles public Set&lt;String&gt; getAdditionalProfiles() { return this.additionalProfiles; } Sets the bean name generator that should be used when generating bean names. @param beanNameGenerator the bean name generator public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) { this.beanNameGenerator = beanNameGenerator; } Sets the underlying environment that should be used with the created application context. @param environment the environment public void setEnvironment(ConfigurableEnvironment environment) { this.isCustomEnvironment = true; this.environment = environment; } Add additional items to the primary sources that will be added to an ApplicationContext when {@link run(String...)} is called. &lt;p&gt; The sources here are added to those that were set in the constructor. Most users should consider using {@link getSources()}{@link setSources(Set)} rather than calling this method. @param additionalPrimarySources the additional primary sources to add @see SpringApplication(Class...) @see getSources() @see setSources(Set) @see getAllSources() public void addPrimarySources(Collection&lt;Class&lt;?&gt;&gt; additionalPrimarySources) { this.primarySources.addAll(additionalPrimarySources); } Returns a mutable set of the sources that will be added to an ApplicationContext when {@link run(String...)} is called. &lt;p&gt; Sources set here will be used in addition to any primary sources set in the constructor. @return the application sources. @see SpringApplication(Class...) @see getAllSources() public Set&lt;String&gt; getSources() { return this.sources; } Set additional sources that will be used to create an ApplicationContext. A source can be: a class name, package name, or an XML resource location. &lt;p&gt; Sources set here will be used in addition to any primary sources set in the constructor. @param sources the application sources to set @see SpringApplication(Class...) @see getAllSources() public void setSources(Set&lt;String&gt; sources) { Assert.notNull(sources, &quot;Sources must not be null&quot;); this.sources = new LinkedHashSet&lt;&gt;(sources); } Return an immutable set of all the sources that will be added to an ApplicationContext when {@link run(String...)} is called. This method combines any primary sources specified in the constructor with any additional ones that have been {@link setSources(Set) explicitly set}. @return an immutable set of all sources public Set&lt;Object&gt; getAllSources() { Set&lt;Object&gt; allSources = new LinkedHashSet&lt;&gt;(); if (!CollectionUtils.isEmpty(this.primarySources)) { allSources.addAll(this.primarySources); } if (!CollectionUtils.isEmpty(this.sources)) { allSources.addAll(this.sources); } return Collections.unmodifiableSet(allSources); } Sets the {@link ResourceLoader} that should be used when loading resources. @param resourceLoader the resource loader public void setResourceLoader(ResourceLoader resourceLoader) { Assert.notNull(resourceLoader, &quot;ResourceLoader must not be null&quot;); this.resourceLoader = resourceLoader; } Return a prefix that should be applied when obtaining configuration properties from the system environment. @return the environment property prefix @since 2.5.0 public String getEnvironmentPrefix() { return this.environmentPrefix; } Set the prefix that should be applied when obtaining configuration properties from the system environment. @param environmentPrefix the environment property prefix to set @since 2.5.0 public void setEnvironmentPrefix(String environmentPrefix) { this.environmentPrefix = environmentPrefix; } Sets the factory that will be called to create the application context. If not set, defaults to a factory that will create {@link AnnotationConfigServletWebServerApplicationContext} for servlet web applications, {@link AnnotationConfigReactiveWebServerApplicationContext} for reactive web applications, and {@link AnnotationConfigApplicationContext} for non-web applications. @param applicationContextFactory the factory for the context @since 2.4.0 public void setApplicationContextFactory(ApplicationContextFactory applicationContextFactory) { this.applicationContextFactory = (applicationContextFactory != null) ? applicationContextFactory : ApplicationContextFactory.DEFAULT; } Sets the {@link ApplicationContextInitializer} that will be applied to the Spring {@link ApplicationContext}. @param initializers the initializers to set public void setInitializers(Collection&lt;? extends ApplicationContextInitializer&lt;?&gt;&gt; initializers) { this.initializers = new ArrayList&lt;&gt;(initializers); } Add {@link ApplicationContextInitializer}s to be applied to the Spring {@link ApplicationContext}. @param initializers the initializers to add public void addInitializers(ApplicationContextInitializer&lt;?&gt;... initializers) { this.initializers.addAll(Arrays.asList(initializers)); } Returns read-only ordered Set of the {@link ApplicationContextInitializer}s that will be applied to the Spring {@link ApplicationContext}. @return the initializers public Set&lt;ApplicationContextInitializer&lt;?&gt;&gt; getInitializers() { return asUnmodifiableOrderedSet(this.initializers); } Sets the {@link ApplicationListener}s that will be applied to the SpringApplication and registered with the {@link ApplicationContext}. @param listeners the listeners to set public void setListeners(Collection&lt;? extends ApplicationListener&lt;?&gt;&gt; listeners) { this.listeners = new ArrayList&lt;&gt;(listeners); } Add {@link ApplicationListener}s to be applied to the SpringApplication and registered with the {@link ApplicationContext}. @param listeners the listeners to add public void addListeners(ApplicationListener&lt;?&gt;... listeners) { this.listeners.addAll(Arrays.asList(listeners)); } Returns read-only ordered Set of the {@link ApplicationListener}s that will be applied to the SpringApplication and registered with the {@link ApplicationContext} . @return the listeners public Set&lt;ApplicationListener&lt;?&gt;&gt; getListeners() { return asUnmodifiableOrderedSet(this.listeners); } Set the {@link ApplicationStartup} to use for collecting startup metrics. @param applicationStartup the application startup to use @since 2.4.0 public void setApplicationStartup(ApplicationStartup applicationStartup) { this.applicationStartup = (applicationStartup != null) ? applicationStartup : ApplicationStartup.DEFAULT; } Returns the {@link ApplicationStartup} used for collecting startup metrics. @return the application startup @since 2.4.0 public ApplicationStartup getApplicationStartup() { return this.applicationStartup; } Return a {@link SpringApplicationShutdownHandlers} instance that can be used to add or remove handlers that perform actions before the JVM is shutdown. @return a {@link SpringApplicationShutdownHandlers} instance @since 2.5.1 public static SpringApplicationShutdownHandlers getShutdownHandlers() { return shutdownHook.getHandlers(); } Static helper that can be used to run a {@link SpringApplication} from the specified source using default settings. @param primarySource the primary source to load @param args the application arguments (usually passed from a Java main method) @return the running {@link ApplicationContext} public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) { return run(new Class&lt;?&gt;[] { primarySource }, args); } Static helper that can be used to run a {@link SpringApplication} from the specified sources using default settings and user supplied arguments. @param primarySources the primary sources to load @param args the application arguments (usually passed from a Java main method) @return the running {@link ApplicationContext} public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args); } A basic main that can be used to launch an application. This method is useful when application sources are defined via a {@literal --spring.main.sources} command line argument. &lt;p&gt; Most developers will want to define their own main method and call the {@link run(Class, String...) run} method instead. @param args command line arguments @throws Exception if the application cannot be started @see SpringApplicationrun(Class[], String[]) @see SpringApplicationrun(Class, String...) public static void main(String[] args) throws Exception { SpringApplication.run(new Class&lt;?&gt;[0], args); } Static helper that can be used to exit a {@link SpringApplication} and obtain a code indicating success (0) or otherwise. Does not throw exceptions but should print stack traces of any encountered. Applies the specified {@link ExitCodeGenerator ExitCodeGenerators} in addition to any Spring beans that implement {@link ExitCodeGenerator}. When multiple generators are available, the first non-zero exit code is used. Generators are ordered based on their {@link Ordered} implementation and {@link Order @Order} annotation. @param context the context to close if possible @param exitCodeGenerators exit code generators @return the outcome (0 if successful) public static int exit(ApplicationContext context, ExitCodeGenerator... exitCodeGenerators) { Assert.notNull(context, &quot;Context must not be null&quot;); int exitCode = 0; try { try { ExitCodeGenerators generators = new ExitCodeGenerators(); Collection&lt;ExitCodeGenerator&gt; beans = context.getBeansOfType(ExitCodeGenerator.class).values(); generators.addAll(exitCodeGenerators); generators.addAll(beans); exitCode = generators.getExitCode(); if (exitCode != 0) { context.publishEvent(new ExitCodeEvent(context, exitCode)); } } finally { close(context); } } catch (Exception ex) { ex.printStackTrace(); exitCode = (exitCode != 0) ? exitCode : 1; } return exitCode; } private static void close(ApplicationContext context) { if (context instanceof ConfigurableApplicationContext closable) { closable.close(); } } private static &lt;E&gt; Set&lt;E&gt; asUnmodifiableOrderedSet(Collection&lt;E&gt; elements) { List&lt;E&gt; list = new ArrayList&lt;&gt;(elements); list.sort(AnnotationAwareOrderComparator.INSTANCE); return new LinkedHashSet&lt;&gt;(list); } {@link BeanFactoryPostProcessor} to re-order our property sources below any {@code @PropertySource} items added by the {@link ConfigurationClassPostProcessor}. private static class PropertySourceOrderingBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered { private final ConfigurableApplicationContext context; PropertySourceOrderingBeanFactoryPostProcessor(ConfigurableApplicationContext context) { this.context = context; } @Override public int getOrder() { return Ordered.HIGHEST_PRECEDENCE; } @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { DefaultPropertiesPropertySource.moveToEnd(this.context.getEnvironment()); } } }" />
      <item value="Web Services client utilities" />
      <item value="Utilities and classes related to validation" />
      <item value="Contains miscellaneous utility classes" />
      <item value="Support classes for reading annotation and class-level metadata." />
      <item value="Utilities and classes related to task execution and scheduling" />
      <item value="General system support classes" />
      <item value="Support for initialization of an SQL database" />
      <item value="Classes and utilities for Spring Security" />
      <item value="Support classes for Reactor integration" />
      <item value="Support for R2DBC connectivity." />
      <item value="JPA Support classes" />
      <item value="Support for item origin tracking." />
      <item value="Support and abstractions across several logging libraries." />
      <item value="Custom support for Liquibase database migration." />
      <item value="Support for parsing JSON." />
      <item value="Support for jOOQ" />
      <item value="Support for Java Message Service (JMS)." />
      <item value="Support for Java Database Connectivity (JDBC)" />
      <item value="Custom enhancements and support for the Jackson project" />
      <item value="Support for providing information about an application." />
      <item value="Custom support for Flyway database migration." />
      <item value="Spring {@link org.springframework.core.env.Environment} support" />
      <item value="Support for failure analysis and reporting" />
      <item value="Support for type conversion." />
      <item value="Classes related to Spring's {@link org.springframework.context.ApplicationContext}." />
      <item value="Low level support for Cloud deployments" />
      <item value="Fluent 'builder' style API to construct a" />
      <item value="Support for describing the availability of Spring Boot applications." />
      <item value="Support classes to provide ANSI color output" />
      <item value="Administration support for Spring Boot applications." />
      <item value="Core Spring Boot classes" />
      <item value="Contains classes related to developing beans -- components based on the JavaBeans™ architecture." />
      <item value="Provides for system input and output through data streams, serialization and the file system." />
      <item value="Provides classes that are fundamental to the design of the Java programming language." />
      <item value="Provides classes for reading and writing the standard ZIP and GZIP file formats." />
      <item value="Classes to support functional-style operations on streams of elements, such as map-reduce transformations on collections." />
      <item value="Service provider classes for the classes in the java.util package" />
      <item value="Service provider classes for the classes in the java.util package." />
      <item value="Classes for matching character sequences against patterns specified by regular expressions." />
      <item value="This package allows applications to store and retrieve user and system preference and configuration data." />
      <item value="Provides the classes and interfaces of the JavaTM 2 platform's core logging facilities." />
      <item value="Provides classes for reading and writing the JAR (Java ARchive) file format, which is based on the standard ZIP file format with an optional manifest file." />
      <item value="Functional interfaces provide target types for lambda expressions and method references." />
      <item value="Interfaces and classes providing a framework for locking and waiting for conditions that is distinct from built-in synchronization and monitors." />
      <item value="A small toolkit of classes that support lock-free thread-safe programming on single variables." />
      <item value="Utility classes commonly useful in concurrent programming." />
      <item value="Contains the collections framework, legacy collection classes, event model, date and time facilities, internationalization, and miscellaneous utility classes (a string tokenizer, a random-number generator, and a bit array)." />
      <item value="Support for time-zones and their rules." />
      <item value="Access to date and time using fields and units, and date time adjusters." />
      <item value="Provides classes to print and parse dates and times." />
      <item value="Generic API for calendar systems other than the default ISO." />
      <item value="The main API for dates, times, instants, and durations." />
      <item value="Provides classes and interfaces for handling text, dates, numbers, and messages in a manner independent of natural languages." />
      <item value="Provides the API for accessing and processing data stored in a data source (usually a relational database) using the JavaTM programming language." />
      <item value="Provides classes and interfaces for key specifications and algorithm parameter specifications." />
      <item value="Provides interfaces for generating RSA (Rivest, Shamir and Adleman AsymmetricCipher algorithm) keys as defined in the RSA Laboratory Technical Note PKCS#1, and DSA (Digital Signature Algorithm) keys as defined in NIST's FIPS-186." />
      <item value="提供用于解析和管理证书、证书吊销列表 (CRL) 和证书路径的类和接口。" />
      <item value="Provides classes and interfaces for parsing and managing certificates, certificate revocation lists (CRLs), and certification paths." />
      <item value="The classes and interfaces in this package have been superseded by classes in the java.security package." />
      <item value="Provides the classes and interfaces for the security framework." />
      <item value="Provides classes and interfaces for supporting the server side of RMI." />
      <item value="Provides a class and two interfaces for the RMI registry." />
      <item value="Provides classes and interface for RMI distributed garbage-collection (DGC)." />
      <item value="Provides support for RMI Object Activation." />
      <item value="Interfaces and classes providing access to file and file system attributes." />
      <item value="Defines interfaces and classes for the Java virtual machine to access files, file attributes, and file systems." />
      <item value="Defines charsets, decoders, and encoders, for translating between bytes and Unicode characters." />
      <item value="Service-provider classes for the java.nio.channels package." />
      <item value="Defines channels, which represent connections to entities that are capable of performing I/O operations, such as files and sockets; defines selectors, for multiplexed, non-blocking I/O operations." />
      <item value="Defines buffers, which are containers for data, and provides an overview of the other NIO packages." />
      <item value="Provides the classes for implementing networking applications." />
      <item value="Provides classes for performing arbitrary-precision integer arithmetic (BigInteger) and arbitrary-precision decimal arithmetic (BigDecimal)." />
      <item value="Provides reference-object classes, which support a limited degree of interaction with the garbage collector." />
      <item value="Provides classes and interfaces for obtaining reflective information about classes and objects." />
      <item value="Provides the management interfaces for monitoring and management of the Java virtual machine and other components in the Java runtime." />
      <item value="The java.lang.invoke package contains dynamic language support provided directly by the Java core class libraries and virtual machine." />
      <item value="你从事什么职业" />
      <item value="你从事什么" />
      <item value="你从事" />
      <item value="你" />
      <item value="trie&#10;" />
      <item value="解决问题" />
      <item value="!binsh ---------------------------------------------------------------------------- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:www.apache.orglicensesLICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. ---------------------------------------------------------------------------- ---------------------------------------------------------------------------- Maven2 Start Up Batch script Required ENV vars: ------------------ JAVA_HOME - location of a JDK home dir Optional ENV vars ----------------- M2_HOME - location of maven2's installed home dir MAVEN_OPTS - parameters passed to the Java VM when running Maven e.g. to debug Maven itself, use set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 MAVEN_SKIP_RC - flag to disable loading of mavenrc files ---------------------------------------------------------------------------- if [ -z &quot;MAVEN_SKIP_RC&quot; ] ; then if [ -f etcmavenrc ] ; then . etcmavenrc fi if [ -f &quot;HOME.mavenrc&quot; ] ; then . &quot;HOME.mavenrc&quot; fi fi OS specific support. var _must_ be set to either true or false. cygwin=false; darwin=false; mingw=false case &quot;`uname`&quot; in CYGWIN) cygwin=true ;; MINGW) mingw=true;; Darwin) darwin=true Look for the Apple JDKs first to preserve the existing behaviour, and then look for the new JDKs provided by Oracle. if [ -z &quot;JAVA_HOME&quot; ] &amp;&amp; [ -L SystemLibraryFrameworksJavaVM.frameworkVersionsCurrentJDK ] ; then Apple JDKs export JAVA_HOME=SystemLibraryFrameworksJavaVM.frameworkVersionsCurrentJDKHome fi if [ -z &quot;JAVA_HOME&quot; ] &amp;&amp; [ -L SystemLibraryJavaJavaVirtualMachinesCurrentJDK ] ; then Apple JDKs export JAVA_HOME=SystemLibraryJavaJavaVirtualMachinesCurrentJDKContentsHome fi if [ -z &quot;JAVA_HOME&quot; ] &amp;&amp; [ -L &quot;LibraryJavaJavaVirtualMachinesCurrentJDK&quot; ] ; then Oracle JDKs export JAVA_HOME=LibraryJavaJavaVirtualMachinesCurrentJDKContentsHome fi if [ -z &quot;JAVA_HOME&quot; ] &amp;&amp; [ -x &quot;usrlibexecjava_home&quot; ]; then Apple JDKs export JAVA_HOME=`usrlibexecjava_home` fi ;; esac if [ -z &quot;JAVA_HOME&quot; ] ; then if [ -r etcgentoo-release ] ; then JAVA_HOME=`java-config --jre-home` fi fi if [ -z &quot;M2_HOME&quot; ] ; then resolve links - 0 may be a link to maven's home PRG=&quot;0&quot; need this for relative symlinks while [ -h &quot;PRG&quot; ] ; do ls=`ls -ld &quot;PRG&quot;` link=`expr &quot;ls&quot; : '.-&gt; \(.\)'` if expr &quot;link&quot; : '.' &gt; devnull; then PRG=&quot;link&quot; else PRG=&quot;`dirname &quot;PRG&quot;`link&quot; fi done saveddir=`pwd` M2_HOME=`dirname &quot;PRG&quot;`.. make it fully qualified M2_HOME=`cd &quot;M2_HOME&quot; &amp;&amp; pwd` cd &quot;saveddir&quot; echo Using m2 at M2_HOME fi For Cygwin, ensure paths are in UNIX format before anything is touched if cygwin ; then [ -n &quot;M2_HOME&quot; ] &amp;&amp; M2_HOME=`cygpath --unix &quot;M2_HOME&quot;` [ -n &quot;JAVA_HOME&quot; ] &amp;&amp; JAVA_HOME=`cygpath --unix &quot;JAVA_HOME&quot;` [ -n &quot;CLASSPATH&quot; ] &amp;&amp; CLASSPATH=`cygpath --path --unix &quot;CLASSPATH&quot;` fi For Migwn, ensure paths are in UNIX format before anything is touched if mingw ; then [ -n &quot;M2_HOME&quot; ] &amp;&amp; M2_HOME=&quot;`(cd &quot;M2_HOME&quot;; pwd)`&quot; [ -n &quot;JAVA_HOME&quot; ] &amp;&amp; JAVA_HOME=&quot;`(cd &quot;JAVA_HOME&quot;; pwd)`&quot; TODO classpath? fi if [ -z &quot;JAVA_HOME&quot; ]; then javaExecutable=&quot;`which javac`&quot; if [ -n &quot;javaExecutable&quot; ] &amp;&amp; ! [ &quot;`expr \&quot;javaExecutable\&quot; : '\([^ ]\)'`&quot; = &quot;no&quot; ]; then readlink(1) is not available as standard on Solaris 10. readLink=`which readlink` if [ ! `expr &quot;readLink&quot; : '\([^ ]\)'` = &quot;no&quot; ]; then if darwin ; then javaHome=&quot;`dirname \&quot;javaExecutable\&quot;`&quot; javaExecutable=&quot;`cd \&quot;javaHome\&quot; &amp;&amp; pwd -P`javac&quot; else javaExecutable=&quot;`readlink -f \&quot;javaExecutable\&quot;`&quot; fi javaHome=&quot;`dirname \&quot;javaExecutable\&quot;`&quot; javaHome=`expr &quot;javaHome&quot; : '\(.\)bin'` JAVA_HOME=&quot;javaHome&quot; export JAVA_HOME fi fi fi if [ -z &quot;JAVACMD&quot; ] ; then if [ -n &quot;JAVA_HOME&quot; ] ; then if [ -x &quot;JAVA_HOMEjreshjava&quot; ] ; then IBM's JDK on AIX uses strange locations for the executables JAVACMD=&quot;JAVA_HOMEjreshjava&quot; else JAVACMD=&quot;JAVA_HOMEbinjava&quot; fi else JAVACMD=&quot;`which java`&quot; fi fi if [ ! -x &quot;JAVACMD&quot; ] ; then echo &quot;Error: JAVA_HOME is not defined correctly.&quot; &gt;&amp;2 echo &quot; We cannot execute JAVACMD&quot; &gt;&amp;2 exit 1 fi if [ -z &quot;JAVA_HOME&quot; ] ; then echo &quot;Warning: JAVA_HOME environment variable is not set.&quot; fi CLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher For Cygwin, switch paths to Windows format before running java if cygwin; then [ -n &quot;M2_HOME&quot; ] &amp;&amp; M2_HOME=`cygpath --path --windows &quot;M2_HOME&quot;` [ -n &quot;JAVA_HOME&quot; ] &amp;&amp; JAVA_HOME=`cygpath --path --windows &quot;JAVA_HOME&quot;` [ -n &quot;CLASSPATH&quot; ] &amp;&amp; CLASSPATH=`cygpath --path --windows &quot;CLASSPATH&quot;` fi traverses directory structure from process work directory to filesystem root first directory with .mvn subdirectory is considered project base directory find_maven_basedir() { local basedir=(pwd) local wdir=(pwd) while [ &quot;wdir&quot; != '' ] ; do if [ -d &quot;wdir&quot;.mvn ] ; then basedir=wdir break fi wdir=(cd &quot;wdir..&quot;; pwd) done echo &quot;{basedir}&quot; } concatenates all lines of a file concat_lines() { if [ -f &quot;1&quot; ]; then echo &quot;(tr -s '\n' ' ' &lt; &quot;1&quot;)&quot; fi } export MAVEN_PROJECTBASEDIR={MAVEN_BASEDIR:-(find_maven_basedir)} MAVEN_OPTS=&quot;(concat_lines &quot;MAVEN_PROJECTBASEDIR.mvnjvm.config&quot;) MAVEN_OPTS&quot; Provide a &quot;standardized&quot; way to retrieve the CLI args that will work with both Windows and non-Windows executions. MAVEN_CMD_LINE_ARGS=&quot;MAVEN_CONFIG @&quot; export MAVEN_CMD_LINE_ARGS WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain exec &quot;JAVACMD&quot; \ MAVEN_OPTS \ -classpath &quot;MAVEN_PROJECTBASEDIR.mvnwrappermaven-wrapper.jar&quot; \ &quot;-Dmaven.home={M2_HOME}&quot; &quot;-Dmaven.multiModuleProjectDirectory={MAVEN_PROJECTBASEDIR}&quot; \ {WRAPPER_LAUNCHER} &quot;@&quot;" />
      <item value="正中靶心" />
      <item value="正中" />
      <item value="目标结果一致" />
      <item value="目标结果" />
      <item value="目标" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="120" />
        <entry key="ENGLISH" value="103" />
        <entry key="LATIN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658450202197" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
    <option name="showExplanation" value="true" />
    <option name="takeWordWhenDialogOpens" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>