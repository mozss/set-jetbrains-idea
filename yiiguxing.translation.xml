<application>
  <component name="AppStorage">
    <option name="maxHistorySize" value="100" />
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogWidth" value="572" />
    <option name="newTranslationDialogX" value="1085" />
    <option name="newTranslationDialogY" value="-798" />
    <histories>
      <item value="交代" />
      <item value="交代&#10;" />
      <item value="没法交代" />
      <item value="没法" />
      <item value="承诺&#10;" />
      <item value="诚信" />
      <item value="承诺" />
      <item value="适应环境" />
      <item value="适应" />
      <item value="积累" />
      <item value="compoun" />
      <item value="compound" />
      <item value="复利" />
      <item value="复利&#10;" />
      <item value="复利&#10;&#10;" />
      <item value="积累&#10;" />
      <item value="管控&#10;" />
      <item value="智库&#10;" />
      <item value="智库" />
      <item value="Return the persistent instance of the given entity class with the given identifier, or null if not found. This method is a thin wrapper around org.hibernate.Session.get(String, Serializable) for convenience. For an explanation of the exact semantics of this method, please do refer to the Hibernate API documentation in the first instance." />
      <item value="Exception hierarchy enabling sophisticated error handling independent of the data access approach in use. For example, when DAOs and data access frameworks use the exceptions in this package (and custom subclasses), calling code can detect and handle common problems such as deadlocks without being tied to a particular data access strategy, such as JDBC. &lt;p&gt;All these exceptions are unchecked, meaning that calling code can leave them uncaught and treat all data access exceptions as fatal. &lt;p&gt;The classes in this package are discussed in Chapter 9 of &lt;a href=&quot;https:www.amazon.comexecobidostgdetail-0764543857&quot;&gt;Expert One-On-One J2EE Design and Development&lt;a&gt; by Rod Johnson (Wrox, 2002). @NonNullApi @NonNullFields package org.springframework.dao; import org.springframework.lang.NonNullApi; import org.springframework.lang.NonNullFields;" />
      <item value=" Expert one on one J2EE design and development" />
      <item value="This package contains interfaces and classes for manipulating Java beans. It is used by most other Spring packages. &lt;p&gt;A BeanWrapper object may be used to set and get bean properties, singly or in bulk. &lt;p&gt;The classes in this package are discussed in Chapter 11 of &lt;a href=&quot;https:www.amazon.comexecobidostgdetail-0764543857&quot;&gt;Expert One-On-One J2EE Design and Development&lt;a&gt; by Rod Johnson (Wrox, 2002). @NonNullApi @NonNullFields package org.springframework.beans; import org.springframework.lang.NonNullApi; import org.springframework.lang.NonNullFields;" />
      <item value="ubinterface of AOP Alliance Advice that allows additional interfaces to be implemented by an Advice, and available via a proxy using that interceptor. This is a fundamental AOP concept called introduction. Introductions are often mixins, enabling the building of composite objects that can achieve many of the goals of multiple inheritance in Java. Compared to IntroductionInfo, this interface allows an advice to implement a range of interfaces that is not necessarily known in advance. Thus an IntroductionAdvisor can be used to specify which interfaces will be exposed in an advised obje" />
      <item value="Filter that restricts matching of a pointcut or introduction to a given set of target classes. Can be used as part of a Pointcut or for the entire targeting of an IntroductionAdvisor. Concrete implementations of this interface typically should provide proper implementations of Object.equals(Object) and Object.hashCode() in order to allow the filter to be used in caching scenarios — for example, in proxies generated by CGLIB" />
      <item value="Base interface holding AOP advice (action to take at a joinpoint) and a filter determining the applicability of the advice (such as a pointcut). This interface is not for use by Spring users, but to allow for commonality in support for different types of advice. Spring AOP is based around around advice delivered via method interception, compliant with the AOP Alliance interception API. The Advisor interface allows support for different types of advice, such as before and after advice, which need not be implemented using interception." />
      <item value="Provides miscellaneous interceptor implementations. More specific interceptors can be found in corresponding functionality packages, like &quot;transaction&quot; and &quot;orm&quot;." />
      <item value="Package containing Spring's basic AOP infrastructure, compliant with the AOP Alliance interfaces. Spring AOP supports proxying interfaces or classes, introductions, and offers static and dynamic pointcuts. Any Spring AOP proxy can be cast to the ProxyConfig AOP configuration interface in this package to add or remove interceptors. The ProxyFactoryBean is a convenient way to create AOP proxies in a BeanFactory or ApplicationContext. However, proxies can be created programmatically using the ProxyFactory class" />
      <item value="AspectJ integration package. Includes Spring AOP advice implementations for AspectJ 5 annotation-style methods, and an AspectJExpressionPointcut: a Spring AOP Pointcut implementation that allows use of the AspectJ pointcut expression language with the Spring AOP runtime framework. Note that use of this package does not require the use of the ajc compiler or AspectJ load-time weaver. It is intended to enable the use of a valuable subset of AspectJ functionality, with consistent semantics, with the proxy-based Spring AOP framework." />
      <item value="Support package for declarative AOP configuration, with XML schema being the primary configuration format." />
      <item value="Support for AOP-based scoping of target objects, with configurable backend." />
      <item value="alliance" />
      <item value="Description of an invocation to a method, given to an interceptor upon method-call. A method invocation is a joinpoint and can be intercepted by a method interceptor." />
      <item value="This interface represents an invocation in the program. An invocation is a joinpoint and can be intercepted by an interceptor." />
      <item value="Interceptor" />
      <item value="Joinpoint" />
      <item value="Invocation" />
      <item value="Constructor Interceptor" />
      <item value="Superclass for all AOP infrastructure exceptions. Unchecked, as such exceptions are fatal and end user code shouldn't be forced to catch them." />
      <item value="Copyright 2002-2018 the original author or authors. Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at https:www.apache.orglicensesLICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License." />
      <item value="public static void main(String[] args) { System.out.println(969);" />
      <item value="喷气式飞机" />
      <item value="喷气式" />
      <item value="hello" />
      <item value="class Bits { Bits() { }" />
      <item value="hello&#10;" />
      <item value="&lt;p&gt;Drop in replacement for the standard class loader of the JVM. You can use it in conjunction with the JavaWrapper to dynamically modifycreate classes as they're requested.&lt;p&gt; &lt;p&gt;This class loader recognizes special requests in a distinct format, i.e., when the name of the requested class contains with &quot;BCEL&quot; it calls the createClass() method with that name (everything bevor the BCEL is considered to be the package name. You can subclass the class loader and override that method. &quot;Normal&quot; classes class can be modified by overriding the modifyClass() method which is called just before defineClass().&lt;p&gt; &lt;p&gt;There may be a number of packages where you have to use the default class loader (which may also be faster). You can define the set of packages where to use the system class loader in the constructor. The default value contains &quot;java.&quot;, &quot;sun.&quot;, &quot;javax.&quot;&lt;p&gt;" />
      <item value="read(List&lt;Integer&gt; list) { super(&quot;ReaderThre" />
      <item value="p" />
      <item value="Copyright (c) $today.year. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan. Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna. Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus. Vestibulum commodo. Ut rhoncus gravida arcu." />
      <item value="transformation" />
      <item value="recording" />
      <item value="Unlock Commercial Features" />
      <item value="https" />
      <item value="hierarchy" />
      <item value="println" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="52" />
        <entry key="ENGLISH" value="53" />
        <entry key="LATIN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1650967441715" />
  </component>
  <component name="Settings">
    <option name="showExplanation" value="true" />
    <option name="showWordsOnStartup" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>